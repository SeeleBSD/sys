/* SPDX-License-Identifier: GPL-2.0 */
/*
 * Header that contains the code (mostly headers) for which Rust bindings
 * will be automatically generated by `bindgen`.
 *
 * Sorted alphabetically.
 */

#include <sys/errno.h>
#include <sys/types.h>
#include <sys/stdint.h>
#include <sys/systm.h>
#include <sys/malloc.h>
#include <sys/device.h>
#include <sys/mutex.h>
#include <sys/rwlock.h>
#include <sys/time.h>
#include <sys/param.h>
#include <sys/ioccom.h>
#include <machine/bus.h>
#include <machine/fdt.h>
#include <drm/asahi/asahidrm.h>
#include <drm/drm_device.h>
#include <drm/drm_drv.h>
#include <drm/drm_file.h>
#include <drm/drm_gem.h>
#include <drm/drm_gem_shmem_helper.h>
#include <drm/drm_ioctl.h>
#include <drm/drm_syncobj.h>
#include <drm/gpu_scheduler.h>
#include <linux/compiler.h>
#include <linux/delay.h>
#include <linux/device.h>
#include <linux/dma-fence.h>
#include <linux/dma-fence-chain.h>
#include <linux/dma-mapping.h>
#include <linux/dma-resv.h>
#include <linux/slab.h>
#include <linux/fs.h>
#include <linux/iommu.h>
#include <linux/ioport.h>
#include <linux/iosys-map.h>
#include <linux/io-pgtable.h>
#include <linux/ktime.h>
#include <linux/lockdep.h>
#include <linux/of.h>
#include <linux/of_address.h>
#include <linux/of_device.h>
#include <linux/platform_device.h>
#include <linux/refcount.h>
#include <linux/wait.h>
#include <linux/sched.h>
#include <linux/slab.h>
#include <linux/soc/apple/rtkit.h>
#include <linux/timekeeping.h>
#include <linux/xarray.h>
#include <linux/printk.h>
#include <linux/gfp_types.h>

#ifdef __arm64__
#include <arm64/dev/rtkit.h>
#endif

int drm_gem_init(struct drm_device *);

#define IS_ERR_VALUE(x) unlikely((x) >= (unsigned long)-ELAST)

void *
BINDING_ERR_PTR(long error)
{
	return (void *) error;
}

long
BINDING_PTR_ERR(const void *ptr)
{
	return (long) ptr;
}

bool
BINDING_IS_ERR(const void *ptr)
{
        return IS_ERR_VALUE((unsigned long)ptr);
}

bool
BINDING_IS_ERR_OR_NULL(const void *ptr)
{
        return !ptr || IS_ERR_VALUE((unsigned long)ptr);
}

void *
BINDING_ERR_CAST(const void *ptr)
{
	return (void *)ptr;
}

int
BINDING_PTR_ERR_OR_ZERO(const void *ptr)
{
	return IS_ERR(ptr)? PTR_ERR(ptr) : 0;
}

paddr_t __arm_lpae_dma_addr(void *pages);

struct proc* BINDING_curproc();

int __init drm_sched_fence_slab_init(void);
void __exit drm_sched_fence_slab_fini(void);

void BINDINGS_mtx_init(struct mutex *, int);

/* `bindgen` gets confused at certain things. */
const size_t ARCH_SLAB_MINALIGN = 8;
const gfp_t BINDINGS_GFP_KERNEL = GFP_KERNEL;
const gfp_t BINDINGS___GFP_ZERO = __GFP_ZERO;
const gfp_t BINDINGS_GFP_KERNEL_ACCOUNT = GFP_KERNEL_ACCOUNT;

const gfp_t BINDINGS_XA_FLAGS_LOCK_IRQ = XA_FLAGS_LOCK_IRQ;
const gfp_t BINDINGS_XA_FLAGS_ALLOC = XA_FLAGS_ALLOC;
const gfp_t BINDINGS_XA_FLAGS_ALLOC1 = XA_FLAGS_ALLOC1;

const u_long BINDINGS_IORESOURCE_MEM = IORESOURCE_MEM;

const uint32_t BINDINGS_IOMMU_READ = IOMMU_READ;
const uint32_t BINDINGS_IOMMU_WRITE = IOMMU_WRITE;
const uint32_t BINDINGS_IOMMU_CACHE = IOMMU_CACHE;
const uint32_t BINDINGS_IOMMU_NOEXEC = IOMMU_NOEXEC;
const uint32_t BINDINGS_IOMMU_MMIO = IOMMU_MMIO;
const uint32_t BINDINGS_IOMMU_PRIV = IOMMU_PRIV;

const unsigned long BINDINGS_IOCPARM_MASK = IOCPARM_MASK;
const size_t BINDINGS_IOCPARM_MAX = IOCPARM_MAX;
const unsigned long BINDINGS_IOC_VOID = IOC_VOID;
const unsigned long BINDINGS_IOC_OUT = IOC_OUT;
const unsigned long BINDINGS_IOC_IN = IOC_IN;
const unsigned long BINDINGS_IOC_INOUT = IOC_INOUT;
const unsigned long BINDINGS_IOC_DIRMASK = IOC_DIRMASK;
